# 北工大图形学

## Introduction

图形学 (Computer Graphics) 是计算机科学的一个分支，主要研究如何使用计算机生成和处理图像。它涵盖了从基本的图形绘制到复杂的三维建模和渲染技术。

图形学严重依赖数学 (Graphics depends on mathematics)，图形学常用的数学工具有：

1. 几何学 (Geometry) 
2. 线性代数 (Linear Algebra) 
3. 微积分 (Calculus)

## Linear Algebra

这部分基本都是比较基础的知识，有关线代的内容可以参考我 Games101 中的笔记，该笔记还介绍到了第8节课才会介绍的齐次坐标 (Homogeneous Coordinates) 的内容，也可以一并了解一下。

[Games101/Lec_1.md#review-of-linear-algebra](../图形学/Games101/Lec_1.md#review-of-linear-algebra)

老师的 pdf 里还提到了基 (Basis) 的概念，指的是一组向量，通过线性组合可以表示空间中的任意向量。正交规范基 (Orthonormal Basis) 是指一组互相垂直且长度为 1 的基向量，比如 $(1,0,0)$、$(0,1,0)$ 和 $(0,0,1)$ 。

这里再顺边标记一下一些常见数学名词的英文翻译：
- 向量 (Vector)
- 矩阵 (Matrix)
- 标量 (Scalar)
- 点积 (Dot Product)
- 叉积 (Cross Product)
- 行列式 (Determinant)
- 交换律 (Commutative Law)
- 结合律 (Associative Law)
- 分配律 (Distributive Law)
- 单位矩阵 (Identity Matrix)
- 逆矩阵 (Inverse Matrix)
- 转置矩阵 (Transpose Matrix)

## 使用 Java 来实现线代中的概念

使用 `Poinf3f` 类来表示三维空间中的点：

::: code-group

```java
public class Point3f {
    public float x, y, z;

    public Point3f() {
        this(0, 0, 0);
    }

    public Point3f(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
```

```kotlin
data class Point3f(var x: Float = 0f, var y: Float = 0f, var z: Float = 0f)
```
:::

使用 `Vector3f` 类来表示三维空间中的向量：

::: code-group

```java
public class Vector3f {
    public float x, y, z;

    public Vector3f() {
        this(0, 0, 0);
    }

    public Vector3f(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public float length() {
        return (float) Math.sqrt(x * x + y * y + z * z);
    }

    public Vector3f normal() { }
    public Vector3f dot(Vector3f v) { }
    public Vector3f cross(Vector3f v) { }
}
```

```kotlin
data class Vector3f(var x: Float = 0f, var y: Float = 0f, var z: Float = 0f) {

    val length: Float
        get() = sqrt(x * x + y * y + z * z).toFloat()

    fun normal(): Vector3f { }
    fun dot(v: Vector3f): Float { }
    fun cross(v: Vector3f): Vector3f { }
}
```
:::

## Rasterization    

将上述数学概念转换为屏幕上的像素，这个过程就叫做光栅化 (Rasterization) 。

### 线

在讲画线和画三角形之前，我们必须先理解插值 (Interpolation)。插值简单来说就是在已知两个点的情况下，计算出这两个点之间的某个点的值。

线形插值 (Linear Interpolation) 是最简单的一种插值方式，就是根据两个端点的某个属性，按照比例关系计算出中间点的属性值：

$$
f(t) = f(A) + \frac{t - A}{B - A} \cdot (f(B) - f(A))
$$


::: info
ppt 里没提到，但在更简单的 t  在0到1的范围内，上面的公式可以简化为更直观的形式：

$$f(t) = f(A) * (1 - t) + f(B) * t$$
:::

接下来讲解一下如何绘制一条线，ppt 值谈到了三种方法：

| 算法 | 原理 | 优点 | 缺点 |
| --- | --- | --- | --- |
| Explicit Form | $y = mx + c$。循环 $x$，计算 $y$ | 概念上简单 | 在斜率 $m > 1$ 时会失效（线条不连续）；$x1 < x0$ 时也失效，需要更多的 if-else 判断，十分麻烦 |
| Implicit Form | $distance((x,y), line) < 0.5$。通过两点确定一条直线，然后检查一个区域内的所有像素，看它离线的距离是否足够近。 | 适用性强 | 它画的是一条无限长的直线 (line)，而不是线段 (segment) ，实际使用中我们用 `x_min` 和 `x_max` 来限制 |
| Parametric Form | $r = p + (q - p) * t$。循环 $t$ 从 $0.0$ 到 $1.0$ | 易于编码  | ppt 中未提及 |

参数法 (Parametric Form) 是最优的，因为它不仅简单，而且完美地契合了插值。

ex: 

```kotlin
for (i in 0..1000) {
    val t = i / 1000.0 
    val point_r = point_p + (point_q - point_p) * t
    setPixel(round(point_r.x), round(point_r.y))
}
```
> 由于 Java 里不支持运算符重载等特性，必要时，我会使用 kotlin 来编写更贴合 ppt 中伪代码的示例。

### 填充三角形

现代图形学中万物皆为三角形，填充三角形是图形学中的基本操作。ppt 中提到了三种方法：
1. 显式法 (Explicit Form / Raster Scan)

    -  按 `x` 坐标（列）循环。对于每一个 `x`，计算出三角形在此处上边缘的 `yMax` 和下边缘的 `yMin`。然后填充 `yMin` 到 `yMax` 之间的所有像素。
    - 插值操作非常复杂：为了计算三角形一点的颜色，在遍历每一列时，你需要计算该列所在直线和三角形上下两条边的交点的颜色，然后根据交点的 `y` 坐标进行插值；但要获得上下交点的颜色，又从上下交点各自所在边的端点进行插值。

2. 隐式法 (Implicit Form / Half-Plane Test)
    - 基于一个事实：一个点 P 如果在所有边的内侧，那它就在三角形内。在逆时针三角形中（A->B->C 逆时针排序），点在所有边的左侧即为在三角形内，顺时针同理点需在边右侧。
    - 插值也很困难，难以做到颜色混合。

3. 参数法 (Parametric Form / Barycentric)
    - 三个权重 $α$ (alpha), $β$ (beta), $γ$ (gamma) 来表示三角形内的任意一点 P。
    - $α$ 是 P 相对于 A 点的权重——离 A 越近, $α$ 越接近 $1.0$；在 BC 边上, $α$ 为 $0$。$β$ 和 $γ$ 同理。
    - 重要性质：
        - $α + β + γ = 1$
        - $α, β, γ >= 0$ 时，点 P 在三角形内
        - 当点在三角形内时，$α, β, γ$ 可以直接用作插值的权重
    - 插值公式，$f$ 可以代表颜色、法线等属性：$f(P) = α * f(A) + β * f(B) + γ * f(C)$

同样，参数法是最推荐的：

```kotlin
for (x in xMin until xMax) {
    for (y in yMin until yMax) {
            
        val alpha = distance(Point(x, y), BC) / distance(A, BC)
        val gamma = distance(Point(x, y), AB) / distance(C, AB)
        val beta = 1.0 - alpha - gamma
       
        if (alpha < 0.0 || beta < 0.0 || gamma < 0.0) {
            continue
        }

        val finalColour = colour(A) * alpha + 
                          colour(B) * beta + 
                          colour(C) * gamma 

        setColour(finalColour)
        setPixel(x, y)
    }
}
```

## Geometric Modelling

### 描述世界

什么是建模？ 它是对世界的描述 ，回答三个问题：
- 物体在哪里 (where)
- 是什么 (what)
- 如何表现 (how) 

如何去描述一个复杂的图形，比如一棵树？我们可以将复杂物体分解 (break into) 为更小的、简单的图元 (primitives) ，比如点，线，球体 (spheres)、圆柱体 (cylinders)、多边形 (polygons) 等 。

如此一来，一棵树可以表述为：棕色圆柱体 + 绿色球体 

通过构造实体几何 (CSG - Constructive Solid Geometry)，我们可以使用布尔运算 (Boolean Operations) 来组合简单图元，形成复杂物体，例如：  
- 并集 (Union) ：A ∪ B
- 差集 (Subtraction) ：A - B
- 异或 (XOR) ：A ⊕ B

![CSG_ex](./images/CSG_ex.png)

值得一提的是，OpenGL 不支持高级的CSG操作（如差集），它只是把所有东西都画出来（即并集）。

### 万物皆为三角形

这是现代图形学的核心原则。

我们已经知道如何绘制填充的三角形 ，一个关键点是：任何多边形都可以被分解（三角化）成一组三角形。只要我们会画三角形，就能绘制任何填充的 2D 多边形 (Polygons)。

3D 多面体 (Polyhedra) 是由多个面 (faces) 组成的，每一个面本质上就是一个 2D 多边形，所以只要我们会画三角形，我们就能绘制任何 3D 多面体。


描述一个长方体，需要定义8个顶点，12 个三角形：
```kotlin
val vertices: Array<IntArray> = arrayOf(
    intArrayOf(-1, -1, -1), // 顶点 0
    intArrayOf(-1, -1,  1), // 顶点 1
    intArrayOf(-1,  1, -1), // 顶点 2
    intArrayOf(-1,  1,  1), // 顶点 3
    intArrayOf( 1, -1, -1), // 顶点 4
    intArrayOf( 1, -1,  1), // 顶点 5
    intArrayOf( 1,  1, -1), // 顶点 6
    intArrayOf( 1,  1,  1)  // 顶点 7
)

val triangles: Array<IntArray> = arrayOf(
    intArrayOf(0, 1, 3),
    intArrayOf(0, 2, 4),
    intArrayOf(0, 1, 4),
    intArrayOf(1, 5, 7),
    intArrayOf(5, 4, 6),
    intArrayOf(2, 3, 7),
    intArrayOf(0, 3, 2),
    intArrayOf(2, 6, 4),
    intArrayOf(1, 4, 5),
    intArrayOf(1, 7, 3),
    intArrayOf(5, 6, 7),
    intArrayOf(2, 7, 6)
)
```

:::  tip
在指定这些三角形时，最好采用 CCW (逆时针) 顺序。
:::

描述球形物体时，我们用面数非常多的多面体来近似圆形物体。

对于圆柱体，可以将其视为一个多边形的柱状体，底面和顶面是多边形，侧面是矩形。通过增加底面和顶面的边数，可以使圆柱体更接近真实的圆柱形状。

对于圆形，我们先讲解如何从球坐标 ($\phi$, $\theta$) 转换为笛卡尔坐标 (x, y, z) 的关键公式：

$
x = r \sin(\phi) \cos(\theta)
$

$
y = r \sin(\phi) \sin(\theta)
$

$
z = r \cos(\phi)
$

<img src="./images/球转笛卡尔.png" alt="球转笛卡尔" style="max-width: 220px; height: auto; margin-left: 24px;">

<!-- ![球转笛卡尔](./images/球转笛卡尔.png) -->

### 计算法线

为了让物体有明暗有质，你需要知道光线如何从表面反射 (reflecting light) 。法线 (Normal) 就是决定反射方向的向量。

对于一个 $p$, $q$, $r$ 三点定义的三角形，我们可以通过叉积 (Cross Product) 来计算法线：
1.  获取两个边的向量：$u = q - p$，$v = r - p$
2. 计算法线： $n = u × v$
3. 可选但推荐—— 标准化 (Normalize) 法线： $\hat{n} = \frac{n}{|n|}$

代码形式：

```kotlin
fun normal(p: Point, q: Point, r: Point): Vector {
    val u = q - p
    val v = r - p
    
    val n = u.cross(v)
    val normalizedN = n / n.length 

    return normalizedN
}
```

为每个三角面计算并使用一个法线，此过程平面着色 (Flat Shading)，会使其看起来棱角分明。为了让近似的圆柱体/球体看起来平滑，我们不使用面法线，而是提供每个顶点 (per vertex) 的法线 。

- 圆柱体：在某个顶点的法线，就是从圆心指向该顶点的水平向量 $(x, y, 0)$ 。

- 球体：对于一个中心在 $(0,0,0)$ 的球体，在表面任意一点 $(x, y, z)$ 的法线就是向量 $(x, y, z)$ 本身。

::: details 为什么点也能有法线？
你可能会疑惑，法线不是用来表示垂直于表面的方向吗，为什么点也能有法线？

这是因为，点法线 (Vertex Normal) 是专门为了服务于计算机图形学中的平滑着色 (Smooth Shading) 而“发明”出来的概念，在现实几何中没有意义，但在图形学中至关重要。
:::

> ppt 里没有介绍怎么利用法线，只是教了如何计算法线，以及它们可以做到什么。

## Projective Rendering

### 投影渲染 vs 光线追踪

投影渲染 (Projective Rendering) 和光线追踪 (Ray Tracing) 是两种不同的图形渲染技术。

- 投影渲染：以物体为中心。为每个三角形，计算它在屏幕上的投影。
- 光线追踪：像素为中心。从每个像素出发，追踪光线与场景中物体的交点。更加复杂且消耗性能，但是能实现更逼真的光影效果。

### 遮挡

如果我们把所有三角形都投影到屏幕上，它们会产生遮挡 (Occlusion) 问题。需要一种手段，正确绘制三角形的前后关系。

画家算法 (Painter's Algorithm) 是一种简单的遮挡解决方案。它的核心思想是：从后往前绘制所有物体。但是该算法无法无法处理循环遮挡（ex：A 挡住 B，B 挡住 C，C 又挡住了 A）。

这是现代图形学的通常采用 Z-Buffering (深度缓冲) 作为解决方案，其核心在于：

1. 开辟一块额外的内存（Z-Buffer），它与屏幕像素一一对应，但它存储的不是颜色，而是深度值 (z coordinate)。
2. 当你要在 $(x,y)$ 处绘制一个新像素时，先计算它的深度 `new_z`。
3. 检查 Z-Buffer 中 $(x,y)$ 位置的旧深度 `old_z`，只在 `new_z` 比 `old_z` 更靠近相机时，才绘制这个新像素，并更新Z-Buffer中的值为 `new_z`。

### 变换

变换参考 Games101 中内容：
- [Games101/Transformations](../图形学/Games101/Lec_1.md#transformations)  
- [Games101/3D Transformations](../图形学/Games101/Lec_1.md#_3d-transformations)

我们此处重点讲解一下法线变换 (Normal Transformation) ——当物体经过变换 (Transformation) 后，法线也需要相应地变换，以确保光照计算的正确性。

我们依次考虑这四种情况：
1. 平移
2. 旋转
3. 缩放
4. 切变

对于平移，法线不变，因为平移不会改变表面的方向，这是很直观的；对于旋转和均匀缩放，法线可以直接使用相同的变换矩阵进行变换，因为旋转和均匀缩放不会改变表面的方向关系。

**对于非均匀缩放，法线需要使用逆转置矩阵 (Inverse Transpose Matrix)**。原因是，缩放会改变表面的方向，如果直接用缩放矩阵变换法线，会导致法线不再垂直于表面。使用逆转置矩阵可以确保法线在变换后仍然垂直于表面。

除了上述方法，你还可以在在缩放/切变之后，再重新计算法线，对于程序来说这其实是一种挺常见的做法。或者干脆避免使用缩放和切变也行。

## Perspective Projection

文艺复兴时期的艺术家发现，现实世界中平行的线（如街道），在画面上并不是平行的 ，它们最后会它们汇聚在一个消失点 (Vanishing Point) 。

::: info Orthographic Projection 平行投影
平行投影是一种简单的投影方式，它保持物体的比例和形状，但不考虑深度信息。所有的投影线都是平行的，因此不会产生消失点，也不存在近大远小。
:::

那么，我们如何模拟近大远小的效果？我们通过相似三角形来做到这一点。

假设场景：
- 你的眼睛在原点 $(0,0,0)$。
- 成像平面（ppt 里称作 Image Plane）在 $z = d$ 处。
- 空间中有一个点 $P = (p_x, p_y, p_z)$。

我们的目标是：计算 P 在成像平面上的投影点 $Q$ 的 $x$ 坐标，即 $q_x$。


![眼睛成像](./images/眼睛成像.png)

根据相似三角形的原理 $\frac{q_x}{d} = \frac{p_x}{p_z}$，我们有：

$$q_x = \frac{d \cdot p_x}{p_z}$$

可以得到结论：$q_x$ 与 $p_x$ 成正比，$q_x$ 与 $p_z$ 成反比。至此，我们成功地模拟出近大远小的效果。不仅如此，这种“除以 $Z$”的效应，会导致远处的物体不仅看起来更小，而且空间被压缩了，提供了纵深感。


::: details
老师的 ppt 里没有介绍这一点，但我觉得说清楚有助于理解。

在现实世界中，光线穿过你眼睛的晶状体，晶状体（就像相机镜头）会把来自3D世界的、发散的光线聚焦，并清晰地成像在眼球后方的2D视网膜上。这个图像是倒立的，我们的大脑会再把它正过来。在图形学中，我们在眼前定义平面，这是为了方便计算，此外这个平面有个专门的名字——近裁平面 (Near Plane)。
:::

人眼视野y有限，于是我们也必须忽略太近或太远的物体。在透视投影中，我们能看到的空间是一个被切掉了顶部和底部的金字塔，这被称为视锥体 (View Frustum) 。

![Frustum](./images/Frustum.png)