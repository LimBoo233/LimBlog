# 北工大图形学

## Introduction

图形学 (Computer Graphics) 是计算机科学的一个分支，主要研究如何使用计算机生成和处理图像。它涵盖了从基本的图形绘制到复杂的三维建模和渲染技术。

图形学严重依赖数学 (Graphics depends on mathematics)，图形学常用的数学工具有：

1. 几何学 (Geometry) 
2. 线性代数 (Linear Algebra) 
3. 微积分 (Calculus)

## Linear Algebra

这部分基本都是比较基础的知识，有关线代的内容可以参考我 Games101 中的笔记，该笔记还介绍到了第8节课才会介绍的齐次坐标 (Homogeneous Coordinates) 的内容，也可以一并了解一下。

[Games101/Lec_1.md#review-of-linear-algebra](../图形学/Games101/Lec_1.md#review-of-linear-algebra)

老师的 pdf 里还提到了基 (Basis) 的概念，指的是一组向量，通过线性组合可以表示空间中的任意向量。正交规范基 (Orthonormal Basis) 是指一组互相垂直且长度为 1 的基向量，比如 $(1,0,0)$、$(0,1,0)$ 和 $(0,0,1)$ 。

这里再顺边标记一下一些常见数学名词的英文翻译：
- 向量 (Vector)
- 矩阵 (Matrix)
- 标量 (Scalar)
- 点积 (Dot Product)
- 叉积 (Cross Product)
- 行列式 (Determinant)
- 交换律 (Commutative Law)
- 结合律 (Associative Law)
- 分配律 (Distributive Law)
- 单位矩阵 (Identity Matrix)
- 逆矩阵 (Inverse Matrix)
- 转置矩阵 (Transpose Matrix)

## 使用 Java 来实现线代中的概念

使用 `Poinf3f` 类来表示三维空间中的点：

::: code-group

```java
public class Point3f {
    public float x, y, z;

    public Point3f() {
        this(0, 0, 0);
    }

    public Point3f(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
```

```kotlin
data class Point3f(var x: Float = 0f, var y: Float = 0f, var z: Float = 0f)
```
:::

使用 `Vector3f` 类来表示三维空间中的向量：

::: code-group

```java
public class Vector3f {
    public float x, y, z;

    public Vector3f() {
        this(0, 0, 0);
    }

    public Vector3f(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public float length() {
        return (float) Math.sqrt(x * x + y * y + z * z);
    }

    public Vector3f normal() { }
    public Vector3f dot(Vector3f v) { }
    public Vector3f cross(Vector3f v) { }
}
```

```kotlin
data class Vector3f(var x: Float = 0f, var y: Float = 0f, var z: Float = 0f) {

    val length: Float
        get() = sqrt(x * x + y * y + z * z).toFloat()

    fun normal(): Vector3f { }
    fun dot(v: Vector3f): Float { }
    fun cross(v: Vector3f): Vector3f { }
}
```
:::

## Rasterization 光栅化

将上述数学概念转换为屏幕上的像素，这个过程就叫做光栅化 (Rasterization) 。

### 线

在讲画线和画三角形之前，我们必须先理解插值 (Interpolation)。插值简单来说就是在已知两个点的情况下，计算出这两个点之间的某个点的值。

线形插值 (Linear Interpolation) 是最简单的一种插值方式，就是根据两个端点的某个属性，按照比例关系计算出中间点的属性值：

$$
f(t) = f(A) + \frac{t - A}{B - A} \cdot (f(B) - f(A))
$$


::: info
ppt 里没提到，但在更简单的 t  在0到1的范围内，上面的公式可以简化为更直观的形式：

$$f(t) = f(A) * (1 - t) + f(B) * t$$
:::

接下来讲解一下如何绘制一条线，ppt 值谈到了三种方法：

| 算法 | 原理 | 优点 | 缺点 |
| --- | --- | --- | --- |
| Explicit Form | $y = mx + c$。循环 $x$，计算 $y$ | 概念上简单 | 在斜率 $m > 1$ 时会失效（线条不连续）；$x1 < x0$ 时也失效，需要更多的 if-else 判断，十分麻烦 |
| Implicit Form | $distance((x,y), line) < 0.5$。通过两点确定一条直线，然后检查一个区域内的所有像素，看它离线的距离是否足够近。 | 适用性强 | 它画的是一条无限长的直线 (line)，而不是线段 (segment) ，实际使用中我们用 `x_min` 和 `x_max` 来限制 |
| Parametric Form | $r = p + (q - p) * t$。循环 $t$ 从 $0.0$ 到 $1.0$ | 易于编码  | ppt 中未提及 |

参数法 (Parametric Form) 是最优的，因为它不仅简单，而且完美地契合了插值。

ex: 

```kotlin
for (i in 0..1000) {
    val t = i / 1000.0 
    val point_r = point_p + (point_q - point_p) * t
    setPixel(round(point_r.x), round(point_r.y))
}
```
> 由于 Java 里不支持运算符重载等特性，必要时，我会使用 kotlin 来编写更贴合 ppt 中伪代码的示例。

### 填充三角形

现代图形学中万物皆为三角形，填充三角形是图形学中的基本操作。ppt 中提到了三种方法：
1. 显式法 (Explicit Form / Raster Scan)

    -  按 `x` 坐标（列）循环。对于每一个 `x`，计算出三角形在此处上边缘的 `yMax` 和下边缘的 `yMin`。然后填充 `yMin` 到 `yMax` 之间的所有像素。
    - 插值操作非常复杂：为了计算三角形一点的颜色，在遍历每一列时，你需要计算该列所在直线和三角形上下两条边的交点的颜色，然后根据交点的 `y` 坐标进行插值；但要获得上下交点的颜色，又从上下交点各自所在边的端点进行插值。

2. 隐式法 (Implicit Form / Half-Plane Test)
    - 基于一个事实：一个点 P 如果在所有边的内侧，那它就在三角形内。在逆时针三角形中（A->B->C 逆时针排序），点在所有边的左侧即为在三角形内，顺时针同理点需在边右侧。
    - 插值也很困难，难以做到颜色混合。

3. 参数法 (Parametric Form / Barycentric)
    - 三个权重 $α$ (alpha), $β$ (beta), $γ$ (gamma) 来表示三角形内的任意一点 P。
    - $α$ 是 P 相对于 A 点的权重——离 A 越近, $α$ 越接近 $1.0$；在 BC 边上, $α$ 为 $0$。$β$ 和 $γ$ 同理。
    - 重要性质：
        - $α + β + γ = 1$
        - $α, β, γ >= 0$ 时，点 P 在三角形内
        - 当点在三角形内时，$α, β, γ$ 可以直接用作插值的权重
    - 插值公式，$f$ 可以代表颜色、法线等属性：$f(P) = α * f(A) + β * f(B) + γ * f(C)$

同样，参数法是最推荐的：

```kotlin
for (x in xMin until xMax) {
    for (y in yMin until yMax) {
            
        val alpha = distance(Point(x, y), BC) / distance(A, BC)
        val gamma = distance(Point(x, y), AB) / distance(C, AB)
        val beta = 1.0 - alpha - gamma
       
        if (alpha < 0.0 || beta < 0.0 || gamma < 0.0) {
            continue
        }

        val finalColour = (colour(A) * alpha) + 
                          (colour(B) * beta) + 
                          (colour(C) * gamma)

        setColour(finalColour)
        setPixel(x, y)
    }
}
```